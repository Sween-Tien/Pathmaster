# Pathmaster
## 1.	需求
### 1.1	问题描述
  	
在一座因地震而发生坍塌的教学楼内，搜救队伍需要通过无人机寻找一条从建筑外部入口到被困师生所在教室的通路。由于教学楼坍塌状况不明，使用无人机的避障和路径搜索功能尤为关键。无人机应当能够识别和躲避障碍物，并智能规划一条安全高效的搜救路线。

### 1.2	可应用的场景

#### 1.2.1	紧急救援：

在自然灾害（如地震、火灾、洪水）或突发事件后，无人机可以快速进入危险或不稳定区域，评估建筑物内部状况，并为搜救队伍规划安全路线。

#### 1.2.2	无人机导航：

为无人机制定安全的导航策略，避免碰撞到障碍物或进入危险区域，确保在复杂环境中的精准定位和移动。

#### 1.2.3城市规划与建筑设计：

在建筑设计阶段模拟坍塌风险，进行应急预案和救援方案的演练，提升建筑物的灾难应对能力。

### 1.3	需要解决的问题

#### 1.3.1	路径搜索

如何在复杂的坍塌环境中，通过无人机智能规划出一条从建筑物入口到被困师生教室的高效路径，避免耽误宝贵的搜救时间。

#### 1.3.2	避障机制

如何利用无人机的传感器，评估周围的障碍物，制定动态避障策略，避免碰撞并确保无人机能够安全到达目标位置

### 1.4	功能、性能和目标

#### 1.4.1	功能

##### 1.4.1.1	路径搜索算法

实现智能的路径规划，支持动态输入环境信息，能够应对复杂、未知的坍塌情况并提供实时反馈。

##### 1.4.1.2	可视化界面

提供一个用户友好的可视化界面，展示教学楼的布局、坍塌区域、无人机的实时路径和行动状况。用户能够直观了解无人机的运动情况，做出必要的决策。

1.4.2	性能

##### 1.4.2.1	计算时间

无人机的路径规划和避障计算时间必须尽量缩短，特别是在紧急救援场景下，需实时生成有效的路线，确保任务能够迅速开始并持续。

##### 1.4.2.2	路径合理性

规划的路径不仅要高效，而且要安全，必须避开所有已知或检测到的障碍物，同时兼顾路径的长度和搜救时间。

##### 1.4.2.3	大规模输入

系统应能处理较复杂的环境信息，如大面积坍塌的教学楼布局和多个障碍物，并对无人机进行多区域、多次的路径搜索。

1.4.3	目标

##### 1.4.3.1	高效安全的路径规划

系统应能成功找到一条从建筑物入口到被困师生所在教室的最佳路径，确保无人机能高效、安全地完成任务，并为后续的人工搜救队伍提供参考路线。

##### 1.4.3.2	直观的用户界面

系统应提供简洁、直观的用户交互界面，方便用户监控无人机的实时位置、飞行路径及障碍物情况，并能在需要时调整路径规划或操作模式。

2.	 设计框架
	 
2.3	抽象数据类型

在无人机搜救任务中，地图的栅格化处理是解决路径规划问题的关键步骤。我们将整个教学楼的布局简化为一个二维平面，并将平面上的每一个栅格（或单元）视为无人机可以探索的区域。每个栅格的状态用一个布尔值或整数进行标记，以区分安全区域和坍塌区域：

> 值为0的栅格代表安全区域（无人机可以飞行的区域）。

> 值为1的栅格代表障碍物或坍塌区域（无人机无法通过）。

这种方式能够有效地抽象复杂的三维建筑环境，使得无人机能够通过二维平面图进行路径规划。在UI界面中，我们使用一个10×10的按钮方阵来模拟教学楼的平面布局。用户可以通过点击这些按钮来手动设置障碍物的位置，每次点击按钮都会将其所在的位置设置为1（即坍塌区域）。

这一过程的意义在于：用户可以根据已知或实时获取的坍塌信息灵活定义无人机的工作环境，而这一动态调整正是应对自然灾害时灵活搜索的核心要求。

2.4	储存结构

在用户设置好障碍物的位置之后，系统会将这些输入转换为一个二维数组。该数组用于表示教学楼的平面图，数组中的每个元素对应一个栅格：

二维数组的每一个元素代表教学楼中的一个特定位置，数组的行列分别代表教学楼的坐标。

在路径搜索过程中，无人机会通过读取这个数组来了解当前的环境状况。算法会根据数组的值进行路径规划，从而避免障碍物，找到一条从入口到被困人员所在教室的安全路径。

这个二维数组的存储结构使得整个地图的状态能够被高效存储和读取，并且为后续的路径搜索算法提供了输入数据。

在实现路径规划的过程中，可以采用诸如A*算法、Dijkstra算法等经典路径搜索算法。这些算法可以基于栅格化地图对每个格子进行探索和计算，从而找到一条从起点（入口）到终点（教室）的最优路径。结合无人机的实时反馈机制，路径搜索算法还可以动态更新以适应可能的环境变化。

此外，在进行路径规划时，系统会在UI中实时可视化无人机的飞行路径，使用户能够清晰地看到无人机的导航过程和障碍物位置。这种可视化界面不仅能够帮助搜救队伍更好地了解当前的救援情况，也能够在必要时对路径规划进行人为干预，确保路径的安全性和高效性。

3.	主要算法的基本思想、实现框架

解决本问题所设计或使用的算法，如何使用算法设计方法(如回溯法、贪婪算法、分支定界法、分治法、动态规划法)

3.1 第一问与第二问

这道题要求我们使用递归的算法来找出最短的道路,我们使用了深度优先搜索（DFS）算法来实现 在递归实现中，算法会从起始节点开始，沿着一条路径深入探索，直到无法继续为止，然后回溯到上一 个节点，尝试其他可能的路径。 dfs 函数就是一个递归函数。它接受当前的行 row 和列 col 作为参数，以及目标的行 end_col 。在每次递归调用中，它会尝试向四个基本方向（东、南、西、北）移动，并在每个方向上递 归地调用自己，直到到达目标位置或者遇到障碍物。 

3.1.1 end_row 和列递归的深度优先搜索的关键步骤包括：

##### 3.1.1.1 递归调用

在每个方向上，通过递归调用 dfs 函数来探索新的节点。

##### 3.1.1.2 回溯

当一个方向的探索完成后，通过从路径中移除最后一个节点（路径回溯）来返回上一个节 点，尝试其他方向。 

##### 3.1.1.3 终止条件

递归的终止条件通常是到达目标节点或者遇到障碍物。 

##### 3.1.1.4 路径记录

在递归过程中，每走一步都会将当前的行、列和方向添加到路径中，直到找到目标节点。

3.1.2 代码的主要思想和特点如下

##### 3.1.2.1 方向编码：

使用常量 EAST 、 SOUTH 、 WEST 、 来定义在每个方向上的移动方式。

##### 3.1.2.2 存储路径

使用 NORTH 来表示四个基本方向，并通过数组 dx 和dy all_paths 向量来存储所有可能的路径，每个路径是一个包含多个元组的向量， 每个元组代表路径中的一步，包括当前的行、列和方向。

3.1.2.3 深度优先搜索 

dfs 函数是深度优先搜索的核心，它递归地探索所有可能的路径。如果当前位置是 障碍物或越界，则直接返回。如果到达终点，则将当前路径添加到 all_paths 中，并更新 best_path （如果当前路径更短）。 

##### 3.1.2.4 路径回溯

在探索完一个方向后，使用 path.pop_back() 来回溯，移除最后一步，以便尝试其他 方向。 

##### 3.1.2.5 标记已访问

为了避免重复访问同一位置，使用 grid[row][col] = 1来标记当前位置已访问，探 索完成后再将其恢复为0。 

##### 3.1.2.6 输出结果

在 main 函数中，首先调用 dfs 函数来找到所有路径，然后输出所有可能的通路和最优 通路。路径的输出使用1-based索引，即实际的行和列索引加1。 

##### 3.1.2.7 最优路径选择

在找到所有路径后，选择路径长度最短的路径作为最优路径

3.2 第三问

这道题我们使用了A*平滑算法来进行善意避障，通过结合A*算法的基本原理和障碍物的安全距离考 虑，形成了一个较为完整的路径寻找解决方案。整体逻辑清晰，适合在简单的网格环境中使用

3.2.1 代码的核心思想包括

##### 3.2.1.1 启发式函数（Heuristic Function）

使用曼哈顿距离作为启发式函数来估计从当前节点到目标节 点的距离。曼哈顿距离是在一个网格中，只能沿着轴移动时，两点之间的最短路径。

 
##### 3.2.1.2 成本函数（Cost Function）：

在A*算法中，每个节点都有一个f值，它是从起点到当前节点的实 际代价（g值）和启发式估计代价（h值）的总和。f = g + h。算法尝试找到具有最小f值的路径。 

##### 3.2.1.3 安全距离惩罚（Safety Penalty）：

为了找到“最安全”的路径，代码引入了一个安全距离惩罚机制。这个机制会检查当前节点周围一定范围内是否有障碍物，并根据障碍物的接近程度增加一个惩罚值，从而影响节点的f值。 

##### 3.2.1.4 优先队列（Priority Queue）：

使用优先队列来存储待处理的节点，优先处理f值最小的节点。 

##### 3.2.1.5 路径重建：

当找到目标节点时，通过回溯每个节点的路径来重建从起点到终点的路径。 

##### 3.2.1.6 边界和障碍物检查：

在移动到新节点之前，代码会检查新节点是否在网格内，以及是否是障碍物。 

##### 3.2.1.7 终止条件：

当找到目标节点或者没有更多的节点可以处理时，算法终止。

3.2.2代码内容分析如下: 

##### 3.2.2.1 网格表示 

使用二维向量 

##### 3.2.2.2 节点结构 

grid 表示网格，其中0表示可通行的区域，1表示障碍物。 定义Node结构体，包含节点的位置（行和列）、从起点到该节点的实际代价g、总代价f（ f = g + h），以及记录路径的 

##### 3.2.2.3 启发式函数 path 

使用曼哈顿距离作为启发式函数 heuristic ，它用于估算当前节点到目标节点的预计代价。 

##### 3.2.2.4 安全惩罚 

safetyPenalty 函数计算当前位置周围一定范围内障碍物对路径的惩罚，惩罚值会随着与障碍物 距离的减小而增加，从而引导算法避免靠近障碍物。 

##### 3.2.2.5 A*搜索过程 

使用优先队列 open_list 存储待处理的节点，按照f值排序，以便每次处理代价最小的节点。 在主循环中，取出队列中的节点，并标记为已访问。如果该节点为目标节点，则返回路径。 对于当前节点的每个邻接节点（东、南、西、北），如果该节点可通行，计算新的代价g和f，并 更新优先队列。 

##### 3.2.2.6 路径输出 

如果找到路径，则输出路径上的每个坐标；如果未找到路径，则输出提示信息。

3.3 第四问

这问需求一个区别于穷举递归算法的算法，我们采用了多个算法来实现

3.3.1 Dijkstra 

我们使用了迪杰斯特拉（Dijkstra）算法来寻找在网格中从起点到终点的最短路径。迪杰斯特拉算法是一 种图搜索算法，它通过维护一个优先队列来确保总是先探索当前已知最短路径的节点。在这段代码中， 每个节点包含当前位置的行、列、从起点到当前位置的距离以及到达该位置的路径。 代码的思想是使用一个优先队列（最小堆）来存储所有待探索的节点，队列中的节点按照它们到起点的 距离进行排序。算法从起点开始，逐步探索周围的节点，更新它们到起点的距离，并在找到更短路径时 更新路径。这个过程一直持续到目标节点被探索或者优先队列为空（表示没有路径可达目标节点）。 代码中定义了一个 Node 结构体来存储每个节点的信息，并重载了>运算符以便在优先队列中按照距离 升序排列。在主函数 main 中，算法被应用于一个具体的网格地图，寻找从入口到目标位置的最短路 径，并打印出路径的坐标和方向 

##### 3.3.1.1 时间复杂度： 

迪杰斯特拉算法的时间复杂度取决于优先队列的实现。在这段代码中，优先队列是基于堆实现的， 其插入和删除操作的时间复杂度为O(log n)，其中n是优先队列中的元素数量。由于每个节点最多被 插入和删除一次，因此总的时间复杂度为O(N log N)，其中N是网格中的节点总数。 

##### 3.3.1.2 空间复杂度： 

代码中使用了三个主要的数据结构：优先队列、距离数组和访问数组。优先队列最多包含所有节 点，因此其空间复杂度为O(N)。距离数组和访问数组的大小与网格的大小相同，因此它们的空间复 杂度也为O(N)。综合考虑，总的空间复杂度为O(N)，其中N是网格中的节点总数。 

3.3.2 贪婪最佳优先搜索 

贪婪最佳优先搜索是一种启发式搜索算法，它使用启发式函数来估计从当前节点到目标节点的距离，并 优先扩展那些具有最低启发式估计的节点。 


代码的核心思想包括： 

##### 3.3.2.1 方向编码：

使用常量 EAST 、 SOUTH 、 WEST 、 NORTH 来表示四个基本方向，并通过数组 dx 和 dy 来定义在每个方向上的移动方式。

##### 3.3.2.2 启发式函数：

使用曼哈顿距离作为启发式函数来估计从当前节点到目标节点的距离。曼哈顿距离是在一个网格中，只能沿着轴移动时，两点之间的最短路径。

##### 3.3.2.3 节点结构体：

定义了一个 Node 结构体，包含当前节点的行、列、优先级（启发式距离）和路径。

##### 3.3.2.4 优先队列：

使用优先队列来存储待处理的节点，优先处理优先级最低的节点。

##### 3.3.2.5 贪婪最佳优先搜索： 

greedyBestFirstSearch 函数是贪婪最佳优先搜索的核心，它使用启发式函数来估计到达目标的成本，并优先扩展那些具有最低启发式估计的节点。

##### 3.3.2.6 遍历和扩展：

遍历四个方向，对于每个方向，如果下一个节点在网格内、不是障碍物且未被访问过，则将其添加到优先队列中。

##### 3.3.2.7 路径记录：

在扩展节点时，将当前节点的路径添加到新节点的路径中。

##### 3.3.2.8 输出结果：

当找到目标节点时，输出从起点到终点的路径。如果遍历完所有节点后仍未找到目标节点，则输出未找到路径的消息。

代码中还包含了一些边界检查，以确保不会访问网格外的节点或障碍物节点。此外，代码使用1-based索引来输出路径，即实际的行和列索引加1，以提高可读性。

3.3.3 广度优先搜索 

广度优先搜索是一种用于图的遍历或搜索的算法，它从树的根节点开始，一层层向外扩展，直到找到目标节点为止。在路径搜索问题中，BFS常用于找到最短路径。

代码的核心思想包括：

##### 3.3.3.1 方向编码：

使用数组 dx 和 dy 来定义在四个基本方向（东、南、西、北）上的移动方式。



##### 3.3.3.2 队列：

使用 queue 来存储待处理的节点，按照广度优先的顺序处理节点。

##### 3.3.3.3 访问标记：

使用 visited 二维数组来标记已经访问过的节点，避免重复处理。

##### 3.3.3.4 路径记录：

使用 paths 二维数组来记录到达每个节点的路径。每个节点的路径是一个包含多个元组的向量，每个元组代表路径中的一步，包括当前的行、列和方向。

##### 3.3.3.5 路径更新：

当探索到一个新的节点时，复制当前节点的路径，并添加新节点的位置和方向信息。



##### 3.3.3.6 终止条件：

当队列空了且没有找到目标节点时，算法终止。

##### 3.3.3.7 输出结果：

在 main 函数中，首先调用 bfsSearch 函数来找到最优路径，然后输出路径的坐标和方向。

3.4 Ambulance 

这段代码使用的思想是一个基于迪杰斯特拉算法的最短路径搜索，用于在加权网格中找到从起点到终点的最短路径。


下面是代码的详细分析：

3.4.1 初始化：

定义了一个二维数组 directions ，用于表示四个基本方向：右、下、左、上。定义了一个 Node 结构体，用于存储节点的坐标（x, y）和从起点到该节点的当前最短路径长度（dist）。

3.4.2 优先队列：

使用 priority_queue （最小堆）来存储待处理的节点。队列中的节点按照它们到起点的距离进行排序，这样总是先处理距离最短的节点。

3.4.3 迪杰斯特拉算法实现：

初始化一个距离数组 dist ，用于存储从起点到每个节点的最短距离，初始值设为 INT_MAX 表示无穷大。初始化一个路径数组 path ，用于记录到达每个节点的路径。将起点加入优先队列，并设置其距离为起点的权重。

3.4.4 探索节点：

当优先队列不为空时，取出队列顶部的节点（即当前已知最短路径的节点）。对于当前节点的每个邻居节点，计算通过当前节点到达邻居节点的距离。如果这个距离比已知的最短距离更短，更新邻居节点的距离和路径，并将其加入优先队列。

3.4.5 路径回溯：

从终点开始，使用路径数组回溯到起点，记录路径上的每个节点和方向。如果当前节点不是起点，根据前一个节点的坐标计算移动方向，并将其添加到结果路径中。如果当前节点是起点，直接将其坐标添加到结果路径中，不记录方向。

3.4.6 输出结果：

将路径反转，因为回溯是从终点到起点的，所以需要反转以得到从起点到终点的路径。在路径末尾添加终点坐标，并标记方向为-1，表示终点。输出路径和路径的总权重。


代码的思想是通过贪心策略来逐步构建最短路径，即在每一步都选择当前已知最短路径的节点进行扩展，直到找到目标节点或探索完所有可达节点。这种方法可以确保找到的是最短路径，因为它总是选择当前已知最短的路径进行扩展。

时间复杂度是O(N log N)，其中N是网格中的节点总数。这是因为每个节点最多被插入和删除一次优先队列，而每次操作的时间复杂度为O(log N)。

空间复杂度是O(N)，因为需要存储所有节点的距离和路径信息，以及一个大小最多为N的优先队列。

4. 测试 

说明需要测试的功能点、测试用例、功能实现程度

4.1第一问与第二问 

4.1.1测试的功能点

4.1.2测试用例

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 0, 0, 1, 0, 0, 0},

{0, 1, 0, 1, 0, 1, 1, 1},

{0, 0, 0, 0, 0, 0, 0, 0},

{0, 1, 1, 1, 1, 1, 1, 0},

{0, 0, 0, 0, 1, 1, 1, 0},

{0, 1, 1, 0, 0, 0, 0, 0},

{1, 1, 0, 0, 0, 0, 0, 0}



4.1.3功能实现

完全实现

4.2第三问 

4.2.1测试的功能点

4.2.2测试用例

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 0, 0, 1, 0, 0, 0},

{0, 1, 0, 1, 0, 1, 1, 1},

{0, 0, 0, 0, 0, 0, 0, 0},

{0, 1, 1, 1, 1, 1, 1, 0},

{0, 0, 0, 0, 1, 1, 1, 0},

{0, 1, 1, 0, 0, 0, 0, 0},

{1, 1, 0, 0, 0, 0, 0, 0}

4.2.3功能实现程度

完全实现

4.3第四问 

4.3.1 Dijkstra 

##### 4.3.1.1	测试的功能点

##### 4.3.1.2 测试用例

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 0, 0, 1, 0, 0, 0},

{0, 1, 0, 1, 0, 1, 1, 1},

{0, 0, 0, 0, 0, 0, 0, 0},

{0, 1, 1, 1, 1, 1, 1, 0},

{0, 0, 0, 0, 1, 1, 1, 0},

{0, 1, 1, 0, 0, 0, 0, 0},

{1, 1, 0, 0, 0, 0, 0, 0}

4.3.1.3功能实现程度

完全实现

4.3.2贪婪 

##### 4.3.2.1测试的功能点

正确输出最短路径


##### 4.3.2.2测试用例

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 0, 0, 1, 0, 0, 0},

{0, 1, 0, 1, 0, 1, 1, 1},

{0, 0, 0, 0, 0, 0, 0, 0},

{0, 1, 1, 1, 1, 1, 1, 0},

{0, 0, 0, 0, 1, 1, 1, 0},

{0, 1, 1, 0, 0, 0, 0, 0},

{1, 1, 0, 0, 0, 0, 0, 0}

##### 4.3.2.3功能实现程度

4.3.3广度优先搜索 

##### 4.3.3.1测试的功能点

正确输出最短路径

##### 4.3.3.2测试用例

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 1, 0, 0, 0, 1, 0},

{0, 0, 0, 0, 1, 0, 0, 0},

{0, 1, 0, 1, 0, 1, 1, 1},

{0, 0, 0, 0, 0, 0, 0, 0},

{0, 1, 1, 1, 1, 1, 1, 0},

{0, 0, 0, 0, 1, 1, 1, 0},

{0, 1, 1, 0, 0, 0, 0, 0},

{1, 1, 0, 0, 0, 0, 0, 0}

##### 4.3.3.3功能实现程度

完全实现
